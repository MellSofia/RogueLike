ЗАДАНИЕ: написать функцию обсчета столкновений, в частности толкание. 
как домашку ПРИКРЕПЛЯТЬ ССЫЛКУ НА РЕПОЗИТОРИЙ ЭТОГО ПРОЕКТА В GITHUB

нужно описать класс Box, который является универсальной оболочкой для любых объектов. в нем храниться указатель на объект, который "лежит" в нем. обсчет взаимодействий (принятие решения, что делать при столкновении) должно происходить в методе collision_hanlder(obj). в нем происходят проверки на то, что это за объект и дальше что с ним делать.

под словом "функция" в задании подразумевается кусок кода, где будет реализован данный функционал. вы можете реализовать его как отдельную функцию, или же как цикл в main(). 

ниже представлена структура класса Box, а так же новый код, который описывает алгоритм работы с ним.
----------------------------------------------
Class Box - это класс, который используется для обсчета физики объектов, в частности коллизии. его можно использовать в массивах, так как он одного и того же типа что и другие. главная задача класса Box - хранить в себе указатель или ссылку на нужный объект, который может быть любого типа. то есть Box используется буквально как коробка - в нее кладутся объекты. после чего выполняются первичные манипуляции и расчеты и когда будет нужно из коробки можно будет достать объект, который эту коробку определил. ниже описаны основные параметры и методы, которые есть у Box:

Class Box:
- int x
- int y
- int speed (если =0 - объект не движется)
- into (указатель на любой объект, который "кладется" в коробку. может быть шаблонным, дабы при get() запросе возвращался сразу нужный объект)

+ put(*obj) (метод "положить в коробку" - передаваемый объект распределяется по параметрам класса коробка: int x = obj->x, into = obj и тд)
+ get() (метод "достать из коробки" - возвращает указатель на объект, который хранит в параметре into)
----------------------------------------------

ПЕРВИЧНЫЙ АЛГОРИТМ ОБРАБОТКИ СОБЫТИЙ. он находится внутри главного цикла игры.

- добавления:
добавить в супер-объект параметры направления, действия и скорости движения (=1 - одна единица в координатах при движении за кадр)


- ЭТАП 1: ввод
собирается ввод с клавиатуры, устанавливаются значения поведелния объектов. NPC (не игровые персонажи) действуют согласно своему паттерну, который задается массивом действий и/или определенными условиями. паттерн применяется к каждому NPC(НПС) через функцию, которая при каждом вызове возвращает следующую операцию из списка паттерна, который, в свою очередь, зациклен.

пример: Entity.whatToDo(int action) // action =1 - движение вверх, =2 - движение вправо, .. =6 - ударить и тд. вместо Int можно использовать и слово с указанием действия (для единообразия эти слова можно сделать константами типа чар, дабы исключить ошибочный ввод команды)

в конце этапа все объекты, которые еще "живы" добавляются в массив обработки boxes


- ЭТАП 2: update
на этом этапе происходит обработка и применение событий, в частности коллизия. запускается цикл по boxes (можно использовать list), внутри которого происходит ряд проверок:
for (cur : boxes)
if (cur.into->speed!=0)
{
 if (display[cur.obj->move().y][cur.obj->.move().x] != '.') 
 // проверка на то, пустое ли то место, куда хочет переместиться объект через  метод move(), который возвращает объект типа COORD, который имеет x и y. если  свободно - движение возможно (координаты объекта = objectArr[i].move()), иначе -   выполняется следующий блок
 {
  // здесь происходит поиск объекта, с которым произошла коллизия через символ на   дисплее или через координаты (можно пока вставить цикл по тому же boxes, который будет искать соответствие по координатам)
  ...
  hited (другая коробочка)
  ...
  // далее происходит сам вызов обработчиков коллизии для объектов:
  cur.into = cur.into->collision_handler(hited.into->collision_handler(cur.into)); #OUTDATED#НЕ ОПТИМАЛЬНО#
  --<OR>--  
  cur.into->collision_handler(hited.into); //внутри коллизии объекта вызывается коллизия хитедОбж. сам метод работает с ссылкой на объект столкновения
  --<OR>--
  collision(cur.into, cur.into); //друж фун-ция, к-ая вызывает не просто их коллизии, а проверяет их типы и соотв. взаимодействия

  // и уже внутри каждой реализации коллизии будут производиться изменения. а   возвращается всегда объект самого объекта, кто делал обработку. Важно! метод move() не изменяет параметры объекта, он просто выводит предполагаемое их   изменение

 } 

}

- ЭТАП 3: output
уже есть в шаблоне - закрепление изменений на дисплее и вывод его на экран.

=================================================
данный алгоритм является опорным и его не стоит использовать прям как есть: код представлен только как сокращение текста и для большей наглядности. можете изменять его 


----------------------------------------------
Так же не забудьте добавить в обсчет коллизии такую ситуацию, когда объект Б, в который собирается врезаться объект А, тоже собирается переместиться. для этого нужно как бы промоделировать следующий шаг (движение) для объекта Б - то есть вызвать у него метод move(), который вернет его координаты после этого такта игры. и уже на основе этой информации нужно будет или считать столкновение, или пропустить объект.
=================================================
ДОПОЛНЕНИЕ:
для расчета столкновений можно использовать большой двумерный массив, который будет содержать Box, а при выводе на экран из этих коробок будут доставаться box.into->icon (можно так же перегрузить operator<< для Box, который сразу будет выводить иконку. коробка буквально будет считаться как строка). так можно сразу проверять пространство перед объектом, ведь не нужно будет вызывать второй цикл для поиска объекта, в который будут врезаться - в этом месте сразу будет объект Box. при движении старое место должно стать точкой ("."), чтобы обозначить пустое пространство. размер этого поля, где просчитываются столкновения можно назвать чанком.